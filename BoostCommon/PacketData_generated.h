// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PACKETDATA_PACKETDATA_H_
#define FLATBUFFERS_GENERATED_PACKETDATA_PACKETDATA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace PacketData {

struct PlayerStat;

struct MonsterStat;

struct Level;

struct C2S_LevelData;
struct C2S_LevelDataBuilder;

struct S2C_LevelData;
struct S2C_LevelDataBuilder;

struct C2S_MonsterData;
struct C2S_MonsterDataBuilder;

struct S2C_MonsterData;
struct S2C_MonsterDataBuilder;

struct C2S_SessionData;
struct C2S_SessionDataBuilder;

struct S2C_SessionData;
struct S2C_SessionDataBuilder;

struct C2S_PlayerData;
struct C2S_PlayerDataBuilder;

struct S2C_PlayerData;
struct S2C_PlayerDataBuilder;

struct Packet;
struct PacketBuilder;

enum MonsterType : int8_t {
  MonsterType_Test = 0,
  MonsterType_MIN = MonsterType_Test,
  MonsterType_MAX = MonsterType_Test
};

inline const MonsterType (&EnumValuesMonsterType())[1] {
  static const MonsterType values[] = {
    MonsterType_Test
  };
  return values;
}

inline const char * const *EnumNamesMonsterType() {
  static const char * const names[2] = {
    "Test",
    nullptr
  };
  return names;
}

inline const char *EnumNameMonsterType(MonsterType e) {
  if (::flatbuffers::IsOutRange(e, MonsterType_Test, MonsterType_Test)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMonsterType()[index];
}

enum PacketType : uint8_t {
  PacketType_NONE = 0,
  PacketType_C2S_LevelData = 1,
  PacketType_S2C_LevelData = 2,
  PacketType_C2S_MonsterData = 3,
  PacketType_S2C_MonsterData = 4,
  PacketType_C2S_SessionData = 5,
  PacketType_S2C_SessionData = 6,
  PacketType_C2S_PlayerData = 7,
  PacketType_S2C_PlayerData = 8,
  PacketType_MIN = PacketType_NONE,
  PacketType_MAX = PacketType_S2C_PlayerData
};

inline const PacketType (&EnumValuesPacketType())[9] {
  static const PacketType values[] = {
    PacketType_NONE,
    PacketType_C2S_LevelData,
    PacketType_S2C_LevelData,
    PacketType_C2S_MonsterData,
    PacketType_S2C_MonsterData,
    PacketType_C2S_SessionData,
    PacketType_S2C_SessionData,
    PacketType_C2S_PlayerData,
    PacketType_S2C_PlayerData
  };
  return values;
}

inline const char * const *EnumNamesPacketType() {
  static const char * const names[10] = {
    "NONE",
    "C2S_LevelData",
    "S2C_LevelData",
    "C2S_MonsterData",
    "S2C_MonsterData",
    "C2S_SessionData",
    "S2C_SessionData",
    "C2S_PlayerData",
    "S2C_PlayerData",
    nullptr
  };
  return names;
}

inline const char *EnumNamePacketType(PacketType e) {
  if (::flatbuffers::IsOutRange(e, PacketType_NONE, PacketType_S2C_PlayerData)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPacketType()[index];
}

template<typename T> struct PacketTypeTraits {
  static const PacketType enum_value = PacketType_NONE;
};

template<> struct PacketTypeTraits<PacketData::C2S_LevelData> {
  static const PacketType enum_value = PacketType_C2S_LevelData;
};

template<> struct PacketTypeTraits<PacketData::S2C_LevelData> {
  static const PacketType enum_value = PacketType_S2C_LevelData;
};

template<> struct PacketTypeTraits<PacketData::C2S_MonsterData> {
  static const PacketType enum_value = PacketType_C2S_MonsterData;
};

template<> struct PacketTypeTraits<PacketData::S2C_MonsterData> {
  static const PacketType enum_value = PacketType_S2C_MonsterData;
};

template<> struct PacketTypeTraits<PacketData::C2S_SessionData> {
  static const PacketType enum_value = PacketType_C2S_SessionData;
};

template<> struct PacketTypeTraits<PacketData::S2C_SessionData> {
  static const PacketType enum_value = PacketType_S2C_SessionData;
};

template<> struct PacketTypeTraits<PacketData::C2S_PlayerData> {
  static const PacketType enum_value = PacketType_C2S_PlayerData;
};

template<> struct PacketTypeTraits<PacketData::S2C_PlayerData> {
  static const PacketType enum_value = PacketType_S2C_PlayerData;
};

bool VerifyPacketType(::flatbuffers::Verifier &verifier, const void *obj, PacketType type);
bool VerifyPacketTypeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) PlayerStat FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t max_hp_;
  uint8_t cur_hp_;
  uint8_t range_;
  uint8_t max_stamina_;
  uint8_t cur_stamina_;
  uint8_t move_speed_;

 public:
  PlayerStat()
      : max_hp_(0),
        cur_hp_(0),
        range_(0),
        max_stamina_(0),
        cur_stamina_(0),
        move_speed_(0) {
  }
  PlayerStat(uint8_t _max_hp, uint8_t _cur_hp, uint8_t _range, uint8_t _max_stamina, uint8_t _cur_stamina, uint8_t _move_speed)
      : max_hp_(::flatbuffers::EndianScalar(_max_hp)),
        cur_hp_(::flatbuffers::EndianScalar(_cur_hp)),
        range_(::flatbuffers::EndianScalar(_range)),
        max_stamina_(::flatbuffers::EndianScalar(_max_stamina)),
        cur_stamina_(::flatbuffers::EndianScalar(_cur_stamina)),
        move_speed_(::flatbuffers::EndianScalar(_move_speed)) {
  }
  uint8_t max_hp() const {
    return ::flatbuffers::EndianScalar(max_hp_);
  }
  uint8_t cur_hp() const {
    return ::flatbuffers::EndianScalar(cur_hp_);
  }
  uint8_t range() const {
    return ::flatbuffers::EndianScalar(range_);
  }
  uint8_t max_stamina() const {
    return ::flatbuffers::EndianScalar(max_stamina_);
  }
  uint8_t cur_stamina() const {
    return ::flatbuffers::EndianScalar(cur_stamina_);
  }
  uint8_t move_speed() const {
    return ::flatbuffers::EndianScalar(move_speed_);
  }
};
FLATBUFFERS_STRUCT_END(PlayerStat, 6);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) MonsterStat FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t monster_type_;
  uint8_t max_hp_;
  uint8_t damage_;
  uint8_t move_speed_;

 public:
  MonsterStat()
      : monster_type_(0),
        max_hp_(0),
        damage_(0),
        move_speed_(0) {
  }
  MonsterStat(PacketData::MonsterType _monster_type, uint8_t _max_hp, uint8_t _damage, uint8_t _move_speed)
      : monster_type_(::flatbuffers::EndianScalar(static_cast<int8_t>(_monster_type))),
        max_hp_(::flatbuffers::EndianScalar(_max_hp)),
        damage_(::flatbuffers::EndianScalar(_damage)),
        move_speed_(::flatbuffers::EndianScalar(_move_speed)) {
  }
  PacketData::MonsterType monster_type() const {
    return static_cast<PacketData::MonsterType>(::flatbuffers::EndianScalar(monster_type_));
  }
  uint8_t max_hp() const {
    return ::flatbuffers::EndianScalar(max_hp_);
  }
  uint8_t damage() const {
    return ::flatbuffers::EndianScalar(damage_);
  }
  uint8_t move_speed() const {
    return ::flatbuffers::EndianScalar(move_speed_);
  }
};
FLATBUFFERS_STRUCT_END(MonsterStat, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Level FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t step_;
  int8_t padding0__;  int16_t padding1__;
  uint32_t goal_money_;
  uint8_t goal_round_;
  int8_t padding2__;  int16_t padding3__;

 public:
  Level()
      : step_(0),
        padding0__(0),
        padding1__(0),
        goal_money_(0),
        goal_round_(0),
        padding2__(0),
        padding3__(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
    (void)padding3__;
  }
  Level(uint8_t _step, uint32_t _goal_money, uint8_t _goal_round)
      : step_(::flatbuffers::EndianScalar(_step)),
        padding0__(0),
        padding1__(0),
        goal_money_(::flatbuffers::EndianScalar(_goal_money)),
        goal_round_(::flatbuffers::EndianScalar(_goal_round)),
        padding2__(0),
        padding3__(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
    (void)padding3__;
  }
  uint8_t step() const {
    return ::flatbuffers::EndianScalar(step_);
  }
  uint32_t goal_money() const {
    return ::flatbuffers::EndianScalar(goal_money_);
  }
  uint8_t goal_round() const {
    return ::flatbuffers::EndianScalar(goal_round_);
  }
};
FLATBUFFERS_STRUCT_END(Level, 12);

struct C2S_LevelData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef C2S_LevelDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSION_ID = 4,
    VT_STEP = 6
  };
  uint32_t session_id() const {
    return GetField<uint32_t>(VT_SESSION_ID, 0);
  }
  uint8_t step() const {
    return GetField<uint8_t>(VT_STEP, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SESSION_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_STEP, 1) &&
           verifier.EndTable();
  }
};

struct C2S_LevelDataBuilder {
  typedef C2S_LevelData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_session_id(uint32_t session_id) {
    fbb_.AddElement<uint32_t>(C2S_LevelData::VT_SESSION_ID, session_id, 0);
  }
  void add_step(uint8_t step) {
    fbb_.AddElement<uint8_t>(C2S_LevelData::VT_STEP, step, 0);
  }
  explicit C2S_LevelDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<C2S_LevelData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<C2S_LevelData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<C2S_LevelData> CreateC2S_LevelData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t session_id = 0,
    uint8_t step = 0) {
  C2S_LevelDataBuilder builder_(_fbb);
  builder_.add_session_id(session_id);
  builder_.add_step(step);
  return builder_.Finish();
}

struct S2C_LevelData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef S2C_LevelDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEVEL = 4
  };
  const PacketData::Level *level() const {
    return GetStruct<const PacketData::Level *>(VT_LEVEL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<PacketData::Level>(verifier, VT_LEVEL, 4) &&
           verifier.EndTable();
  }
};

struct S2C_LevelDataBuilder {
  typedef S2C_LevelData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_level(const PacketData::Level *level) {
    fbb_.AddStruct(S2C_LevelData::VT_LEVEL, level);
  }
  explicit S2C_LevelDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<S2C_LevelData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<S2C_LevelData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<S2C_LevelData> CreateS2C_LevelData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const PacketData::Level *level = nullptr) {
  S2C_LevelDataBuilder builder_(_fbb);
  builder_.add_level(level);
  return builder_.Finish();
}

struct C2S_MonsterData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef C2S_MonsterDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MONSTER_TYPE = 4
  };
  PacketData::MonsterType monster_type() const {
    return static_cast<PacketData::MonsterType>(GetField<int8_t>(VT_MONSTER_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MONSTER_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct C2S_MonsterDataBuilder {
  typedef C2S_MonsterData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_monster_type(PacketData::MonsterType monster_type) {
    fbb_.AddElement<int8_t>(C2S_MonsterData::VT_MONSTER_TYPE, static_cast<int8_t>(monster_type), 0);
  }
  explicit C2S_MonsterDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<C2S_MonsterData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<C2S_MonsterData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<C2S_MonsterData> CreateC2S_MonsterData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    PacketData::MonsterType monster_type = PacketData::MonsterType_Test) {
  C2S_MonsterDataBuilder builder_(_fbb);
  builder_.add_monster_type(monster_type);
  return builder_.Finish();
}

struct S2C_MonsterData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef S2C_MonsterDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MONSTER_STAT = 4
  };
  const PacketData::MonsterStat *monster_stat() const {
    return GetStruct<const PacketData::MonsterStat *>(VT_MONSTER_STAT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<PacketData::MonsterStat>(verifier, VT_MONSTER_STAT, 1) &&
           verifier.EndTable();
  }
};

struct S2C_MonsterDataBuilder {
  typedef S2C_MonsterData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_monster_stat(const PacketData::MonsterStat *monster_stat) {
    fbb_.AddStruct(S2C_MonsterData::VT_MONSTER_STAT, monster_stat);
  }
  explicit S2C_MonsterDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<S2C_MonsterData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<S2C_MonsterData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<S2C_MonsterData> CreateS2C_MonsterData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const PacketData::MonsterStat *monster_stat = nullptr) {
  S2C_MonsterDataBuilder builder_(_fbb);
  builder_.add_monster_stat(monster_stat);
  return builder_.Finish();
}

struct C2S_SessionData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef C2S_SessionDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSION_ID = 4
  };
  uint32_t session_id() const {
    return GetField<uint32_t>(VT_SESSION_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SESSION_ID, 4) &&
           verifier.EndTable();
  }
};

struct C2S_SessionDataBuilder {
  typedef C2S_SessionData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_session_id(uint32_t session_id) {
    fbb_.AddElement<uint32_t>(C2S_SessionData::VT_SESSION_ID, session_id, 0);
  }
  explicit C2S_SessionDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<C2S_SessionData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<C2S_SessionData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<C2S_SessionData> CreateC2S_SessionData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t session_id = 0) {
  C2S_SessionDataBuilder builder_(_fbb);
  builder_.add_session_id(session_id);
  return builder_.Finish();
}

struct S2C_SessionData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef S2C_SessionDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSION_ID = 4,
    VT_STEP = 6,
    VT_ALL_PLAYER_ID = 8,
    VT_USABLE_MONEY = 10,
    VT_NOW_ROUND = 12
  };
  uint32_t session_id() const {
    return GetField<uint32_t>(VT_SESSION_ID, 0);
  }
  uint8_t step() const {
    return GetField<uint8_t>(VT_STEP, 0);
  }
  const ::flatbuffers::Vector<uint32_t> *all_player_id() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_ALL_PLAYER_ID);
  }
  uint32_t usable_money() const {
    return GetField<uint32_t>(VT_USABLE_MONEY, 0);
  }
  uint8_t now_round() const {
    return GetField<uint8_t>(VT_NOW_ROUND, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SESSION_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_STEP, 1) &&
           VerifyOffset(verifier, VT_ALL_PLAYER_ID) &&
           verifier.VerifyVector(all_player_id()) &&
           VerifyField<uint32_t>(verifier, VT_USABLE_MONEY, 4) &&
           VerifyField<uint8_t>(verifier, VT_NOW_ROUND, 1) &&
           verifier.EndTable();
  }
};

struct S2C_SessionDataBuilder {
  typedef S2C_SessionData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_session_id(uint32_t session_id) {
    fbb_.AddElement<uint32_t>(S2C_SessionData::VT_SESSION_ID, session_id, 0);
  }
  void add_step(uint8_t step) {
    fbb_.AddElement<uint8_t>(S2C_SessionData::VT_STEP, step, 0);
  }
  void add_all_player_id(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> all_player_id) {
    fbb_.AddOffset(S2C_SessionData::VT_ALL_PLAYER_ID, all_player_id);
  }
  void add_usable_money(uint32_t usable_money) {
    fbb_.AddElement<uint32_t>(S2C_SessionData::VT_USABLE_MONEY, usable_money, 0);
  }
  void add_now_round(uint8_t now_round) {
    fbb_.AddElement<uint8_t>(S2C_SessionData::VT_NOW_ROUND, now_round, 0);
  }
  explicit S2C_SessionDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<S2C_SessionData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<S2C_SessionData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<S2C_SessionData> CreateS2C_SessionData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t session_id = 0,
    uint8_t step = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> all_player_id = 0,
    uint32_t usable_money = 0,
    uint8_t now_round = 0) {
  S2C_SessionDataBuilder builder_(_fbb);
  builder_.add_usable_money(usable_money);
  builder_.add_all_player_id(all_player_id);
  builder_.add_session_id(session_id);
  builder_.add_now_round(now_round);
  builder_.add_step(step);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<S2C_SessionData> CreateS2C_SessionDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t session_id = 0,
    uint8_t step = 0,
    const std::vector<uint32_t> *all_player_id = nullptr,
    uint32_t usable_money = 0,
    uint8_t now_round = 0) {
  auto all_player_id__ = all_player_id ? _fbb.CreateVector<uint32_t>(*all_player_id) : 0;
  return PacketData::CreateS2C_SessionData(
      _fbb,
      session_id,
      step,
      all_player_id__,
      usable_money,
      now_round);
}

struct C2S_PlayerData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef C2S_PlayerDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSION_ID = 4,
    VT_PLAYER_ID = 6
  };
  uint32_t session_id() const {
    return GetField<uint32_t>(VT_SESSION_ID, 0);
  }
  uint32_t player_id() const {
    return GetField<uint32_t>(VT_PLAYER_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SESSION_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_ID, 4) &&
           verifier.EndTable();
  }
};

struct C2S_PlayerDataBuilder {
  typedef C2S_PlayerData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_session_id(uint32_t session_id) {
    fbb_.AddElement<uint32_t>(C2S_PlayerData::VT_SESSION_ID, session_id, 0);
  }
  void add_player_id(uint32_t player_id) {
    fbb_.AddElement<uint32_t>(C2S_PlayerData::VT_PLAYER_ID, player_id, 0);
  }
  explicit C2S_PlayerDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<C2S_PlayerData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<C2S_PlayerData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<C2S_PlayerData> CreateC2S_PlayerData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t session_id = 0,
    uint32_t player_id = 0) {
  C2S_PlayerDataBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_session_id(session_id);
  return builder_.Finish();
}

struct S2C_PlayerData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef S2C_PlayerDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYER_ID = 4,
    VT_PLAYER_STAT = 6
  };
  uint32_t player_id() const {
    return GetField<uint32_t>(VT_PLAYER_ID, 0);
  }
  const PacketData::PlayerStat *player_stat() const {
    return GetStruct<const PacketData::PlayerStat *>(VT_PLAYER_STAT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_ID, 4) &&
           VerifyField<PacketData::PlayerStat>(verifier, VT_PLAYER_STAT, 1) &&
           verifier.EndTable();
  }
};

struct S2C_PlayerDataBuilder {
  typedef S2C_PlayerData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_player_id(uint32_t player_id) {
    fbb_.AddElement<uint32_t>(S2C_PlayerData::VT_PLAYER_ID, player_id, 0);
  }
  void add_player_stat(const PacketData::PlayerStat *player_stat) {
    fbb_.AddStruct(S2C_PlayerData::VT_PLAYER_STAT, player_stat);
  }
  explicit S2C_PlayerDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<S2C_PlayerData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<S2C_PlayerData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<S2C_PlayerData> CreateS2C_PlayerData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_id = 0,
    const PacketData::PlayerStat *player_stat = nullptr) {
  S2C_PlayerDataBuilder builder_(_fbb);
  builder_.add_player_stat(player_stat);
  builder_.add_player_id(player_id);
  return builder_.Finish();
}

struct Packet FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_TYPE_TYPE = 6,
    VT_TYPE = 8
  };
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  PacketData::PacketType type_type() const {
    return static_cast<PacketData::PacketType>(GetField<uint8_t>(VT_TYPE_TYPE, 0));
  }
  const void *type() const {
    return GetPointer<const void *>(VT_TYPE);
  }
  template<typename T> const T *type_as() const;
  const PacketData::C2S_LevelData *type_as_C2S_LevelData() const {
    return type_type() == PacketData::PacketType_C2S_LevelData ? static_cast<const PacketData::C2S_LevelData *>(type()) : nullptr;
  }
  const PacketData::S2C_LevelData *type_as_S2C_LevelData() const {
    return type_type() == PacketData::PacketType_S2C_LevelData ? static_cast<const PacketData::S2C_LevelData *>(type()) : nullptr;
  }
  const PacketData::C2S_MonsterData *type_as_C2S_MonsterData() const {
    return type_type() == PacketData::PacketType_C2S_MonsterData ? static_cast<const PacketData::C2S_MonsterData *>(type()) : nullptr;
  }
  const PacketData::S2C_MonsterData *type_as_S2C_MonsterData() const {
    return type_type() == PacketData::PacketType_S2C_MonsterData ? static_cast<const PacketData::S2C_MonsterData *>(type()) : nullptr;
  }
  const PacketData::C2S_SessionData *type_as_C2S_SessionData() const {
    return type_type() == PacketData::PacketType_C2S_SessionData ? static_cast<const PacketData::C2S_SessionData *>(type()) : nullptr;
  }
  const PacketData::S2C_SessionData *type_as_S2C_SessionData() const {
    return type_type() == PacketData::PacketType_S2C_SessionData ? static_cast<const PacketData::S2C_SessionData *>(type()) : nullptr;
  }
  const PacketData::C2S_PlayerData *type_as_C2S_PlayerData() const {
    return type_type() == PacketData::PacketType_C2S_PlayerData ? static_cast<const PacketData::C2S_PlayerData *>(type()) : nullptr;
  }
  const PacketData::S2C_PlayerData *type_as_S2C_PlayerData() const {
    return type_type() == PacketData::PacketType_S2C_PlayerData ? static_cast<const PacketData::S2C_PlayerData *>(type()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           VerifyField<uint8_t>(verifier, VT_TYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_TYPE) &&
           VerifyPacketType(verifier, type(), type_type()) &&
           verifier.EndTable();
  }
};

template<> inline const PacketData::C2S_LevelData *Packet::type_as<PacketData::C2S_LevelData>() const {
  return type_as_C2S_LevelData();
}

template<> inline const PacketData::S2C_LevelData *Packet::type_as<PacketData::S2C_LevelData>() const {
  return type_as_S2C_LevelData();
}

template<> inline const PacketData::C2S_MonsterData *Packet::type_as<PacketData::C2S_MonsterData>() const {
  return type_as_C2S_MonsterData();
}

template<> inline const PacketData::S2C_MonsterData *Packet::type_as<PacketData::S2C_MonsterData>() const {
  return type_as_S2C_MonsterData();
}

template<> inline const PacketData::C2S_SessionData *Packet::type_as<PacketData::C2S_SessionData>() const {
  return type_as_C2S_SessionData();
}

template<> inline const PacketData::S2C_SessionData *Packet::type_as<PacketData::S2C_SessionData>() const {
  return type_as_S2C_SessionData();
}

template<> inline const PacketData::C2S_PlayerData *Packet::type_as<PacketData::C2S_PlayerData>() const {
  return type_as_C2S_PlayerData();
}

template<> inline const PacketData::S2C_PlayerData *Packet::type_as<PacketData::S2C_PlayerData>() const {
  return type_as_S2C_PlayerData();
}

struct PacketBuilder {
  typedef Packet Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(Packet::VT_TIMESTAMP, timestamp, 0);
  }
  void add_type_type(PacketData::PacketType type_type) {
    fbb_.AddElement<uint8_t>(Packet::VT_TYPE_TYPE, static_cast<uint8_t>(type_type), 0);
  }
  void add_type(::flatbuffers::Offset<void> type) {
    fbb_.AddOffset(Packet::VT_TYPE, type);
  }
  explicit PacketBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Packet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Packet>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Packet> CreatePacket(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t timestamp = 0,
    PacketData::PacketType type_type = PacketData::PacketType_NONE,
    ::flatbuffers::Offset<void> type = 0) {
  PacketBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_type(type);
  builder_.add_type_type(type_type);
  return builder_.Finish();
}

inline bool VerifyPacketType(::flatbuffers::Verifier &verifier, const void *obj, PacketType type) {
  switch (type) {
    case PacketType_NONE: {
      return true;
    }
    case PacketType_C2S_LevelData: {
      auto ptr = reinterpret_cast<const PacketData::C2S_LevelData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketType_S2C_LevelData: {
      auto ptr = reinterpret_cast<const PacketData::S2C_LevelData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketType_C2S_MonsterData: {
      auto ptr = reinterpret_cast<const PacketData::C2S_MonsterData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketType_S2C_MonsterData: {
      auto ptr = reinterpret_cast<const PacketData::S2C_MonsterData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketType_C2S_SessionData: {
      auto ptr = reinterpret_cast<const PacketData::C2S_SessionData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketType_S2C_SessionData: {
      auto ptr = reinterpret_cast<const PacketData::S2C_SessionData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketType_C2S_PlayerData: {
      auto ptr = reinterpret_cast<const PacketData::C2S_PlayerData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketType_S2C_PlayerData: {
      auto ptr = reinterpret_cast<const PacketData::S2C_PlayerData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPacketTypeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPacketType(
        verifier,  values->Get(i), types->GetEnum<PacketType>(i))) {
      return false;
    }
  }
  return true;
}

inline const PacketData::Packet *GetPacket(const void *buf) {
  return ::flatbuffers::GetRoot<PacketData::Packet>(buf);
}

inline const PacketData::Packet *GetSizePrefixedPacket(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<PacketData::Packet>(buf);
}

inline bool VerifyPacketBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<PacketData::Packet>(nullptr);
}

inline bool VerifySizePrefixedPacketBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<PacketData::Packet>(nullptr);
}

inline void FinishPacketBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<PacketData::Packet> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPacketBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<PacketData::Packet> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace PacketData

#endif  // FLATBUFFERS_GENERATED_PACKETDATA_PACKETDATA_H_
